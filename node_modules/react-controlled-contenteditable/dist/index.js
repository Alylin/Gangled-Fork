"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/contentEditable/index.tsx
var contentEditable_exports = {};
__export(contentEditable_exports, {
  default: () => contentEditable_default
});
module.exports = __toCommonJS(contentEditable_exports);
var import_react5 = __toESM(require("react"));
var import_react_merge_refs = require("react-merge-refs");

// src/contentEditable/useCaretPositioning.tsx
var import_react4 = require("react");

// src/contentEditable/useUndo.tsx
var import_react2 = require("react");
var import_react3 = __toESM(require("fast-deep-equal/react"));

// src/contentEditable/useSaveRestoreRange.tsx
var import_react = require("react");

// src/contentEditable/common.tsx
var getNodeDepthAndIndexes = (node, highestParentAttribute) => {
  var _a, _b;
  if (!node && !highestParentAttribute)
    return null;
  let searchNode = node;
  let attribute = node.nodeType === 1 ? (searchNode == null ? void 0 : searchNode.getAttribute(
    highestParentAttribute
  )) === "true" : false;
  let depth = 0;
  let indexes = [];
  while (!attribute) {
    if ((_a = searchNode == null ? void 0 : searchNode.parentElement) == null ? void 0 : _a.childNodes) {
      indexes.push(
        Array.prototype.indexOf.call(
          (_b = searchNode == null ? void 0 : searchNode.parentElement) == null ? void 0 : _b.childNodes,
          searchNode
        )
      );
    }
    searchNode = (searchNode == null ? void 0 : searchNode.parentElement) || null;
    if (!searchNode) {
      break;
    }
    if ((searchNode == null ? void 0 : searchNode.getAttribute(
      highestParentAttribute
    )) === "true") {
      attribute = true;
    }
    if (depth > 1e3) {
      depth = -1;
      break;
    }
    depth++;
  }
  return { depth, indexes: indexes.reverse() };
};
var getNestedNodeByIndexesAndDepth = (element, indexes, depth) => {
  if (indexes.length > 0 && depth < 0 && !Element)
    return null;
  let node = element;
  let currentDepth = 0;
  while (currentDepth !== depth) {
    node = node == null ? void 0 : node.childNodes[indexes[currentDepth]];
    currentDepth++;
    if (currentDepth > 1e4) {
      break;
    }
  }
  return node;
};
var getMatchedContainer = (contentEditable, startContainerPos) => {
  const { depth, indexes } = startContainerPos;
  return getNestedNodeByIndexesAndDepth(contentEditable, indexes, depth);
};
var getRange = () => {
  const sel = document.getSelection();
  if (typeof (sel == null ? void 0 : sel.rangeCount) === "undefined")
    return;
  const range = sel.rangeCount > 0 ? sel == null ? void 0 : sel.getRangeAt(0) : null;
  return range;
};

// src/contentEditable/useSaveRestoreRange.tsx
var useSaveRestoreRange = (el) => {
  const [caretPosition, setCaretPosition] = (0, import_react.useState)();
  const isPaste = (0, import_react.useRef)(false);
  const getCaretPosition = (0, import_react.useCallback)(() => {
    const range = getRange();
    if (range) {
      const startContainerPos = getNodeDepthAndIndexes(
        range.startContainer,
        "contenteditable"
      );
      const endContainerPos = getNodeDepthAndIndexes(
        range.endContainer,
        "contenteditable"
      );
      if (!startContainerPos || !endContainerPos)
        return;
      return {
        endOffset: range.endOffset,
        startOffset: range.startOffset,
        startContainerPos,
        endContainerPos
      };
    }
  }, []);
  const saveRange = (0, import_react.useCallback)(() => {
    setCaretPosition(getCaretPosition());
  }, [getCaretPosition]);
  const getMatchedContainers = (0, import_react.useCallback)(() => {
    if (!caretPosition || !el)
      return { start: null, end: null };
    const end = getMatchedContainer(el, caretPosition.endContainerPos);
    const start = getMatchedContainer(el, caretPosition.startContainerPos);
    return { start, end };
  }, [caretPosition, el]);
  const restoreCaretPosition = (0, import_react.useCallback)(() => {
    var _a, _b;
    const sel = document.getSelection();
    const range = new Range();
    if (caretPosition) {
      const matchedEndContainer = (_a = getMatchedContainers()) == null ? void 0 : _a.end;
      const matchedStartContainer = (_b = getMatchedContainers()) == null ? void 0 : _b.start;
      if (matchedEndContainer && matchedStartContainer) {
        range.setStart(
          matchedStartContainer,
          caretPosition.startOffset
        );
        range.setEnd(matchedEndContainer, caretPosition.endOffset);
        if (isPaste.current) {
          range.setEnd(
            matchedStartContainer,
            caretPosition.startOffset
          );
          isPaste.current = false;
        }
      }
      sel == null ? void 0 : sel.removeAllRanges();
      sel == null ? void 0 : sel.addRange(range);
    }
  }, [caretPosition, getMatchedContainers]);
  (0, import_react.useLayoutEffect)(() => {
    const element = el;
    const handleOnPaste = () => {
      isPaste.current = true;
    };
    element == null ? void 0 : element.addEventListener("paste", handleOnPaste);
    return () => element == null ? void 0 : element.removeEventListener("paste", handleOnPaste);
  }, [el]);
  return {
    caretPosition,
    getMatchedContainers,
    saveRange,
    restoreCaretPosition,
    getCaretPosition,
    setCaretPosition
  };
};
var useSaveRestoreRange_default = useSaveRestoreRange;

// src/contentEditable/useUndo.tsx
var keys = ["Backspace", "Paste", "Enter", "Delete"];
var useUndo = (el) => {
  const [allChanges, setAllChanges] = (0, import_react2.useState)();
  const [undoState, setUndoState] = (0, import_react2.useState)();
  const [prevCaretPosition, setPrevCaretPost] = (0, import_react2.useState)();
  const hasCaretPosChangedByUser = (0, import_react2.useRef)(false);
  const { getCaretPosition } = useSaveRestoreRange_default(el);
  const detectCaretChange = (0, import_react2.useCallback)(() => {
    const caretPosition = getCaretPosition();
    if ((caretPosition == null ? void 0 : caretPosition.endContainerPos) && prevCaretPosition && (0, import_react3.default)(
      caretPosition == null ? void 0 : caretPosition.endContainerPos,
      prevCaretPosition == null ? void 0 : prevCaretPosition.endContainerPos
    )) {
      const diff = Math.abs(
        caretPosition.endOffset - prevCaretPosition.endOffset
      );
      if (diff > 2) {
        hasCaretPosChangedByUser.current = true;
        return;
      }
      hasCaretPosChangedByUser.current = false;
      return;
    }
    hasCaretPosChangedByUser.current = true;
  }, [prevCaretPosition, getCaretPosition]);
  const saveChanges = (0, import_react2.useCallback)(
    (action) => {
      const caretPos = getCaretPosition();
      if (!el || !caretPos)
        return;
      setAllChanges((prev) => {
        let prevChanges = [...prev ? prev : []];
        const lastChange = prev ? prev[(prev == null ? void 0 : prev.length) - 1] : null;
        if ((lastChange == null ? void 0 : lastChange.action) === action || (lastChange == null ? void 0 : lastChange.html) === el.innerHTML) {
          return prevChanges;
        }
        return [
          ...prevChanges,
          {
            caretPosition: caretPos,
            html: el.innerHTML,
            action
          }
        ];
      });
    },
    [el, getCaretPosition]
  );
  const undo = (0, import_react2.useCallback)(
    (e) => {
      if (e.key === "Undo" || e.ctrlKey && e.code === "KeyZ") {
        let changes = [...allChanges ? allChanges : []];
        let lastChange = changes.pop();
        setUndoState(lastChange);
        setAllChanges(changes);
      }
    },
    [allChanges]
  );
  const handleKeyDown = (0, import_react2.useCallback)(
    (e) => {
      const isLetter = e.code.substring(0, 3).toLocaleLowerCase() === "key";
      const isNumber = e.code.substring(0, 6).toLocaleLowerCase() === "numpad";
      const isDigit = e.code.substring(0, 5).toLocaleLowerCase() === "digit";
      const isChar = isDigit || isNumber || isLetter;
      if (keys.includes(e.key) || e.ctrlKey && e.code === "KeyV" || e.shiftKey && e.code === "Enter" || isLetter) {
        let action = e.ctrlKey && e.code === "KeyV" ? "Paste" : isChar ? "isChar" : e.key;
        if (action === "isChar") {
          setPrevCaretPost(getCaretPosition());
        }
        if (action === "isChar" && hasCaretPosChangedByUser.current) {
          action = "caretPosChangedByUser";
          hasCaretPosChangedByUser.current = false;
        }
        saveChanges(action);
      }
      undo(e);
    },
    [
      saveChanges,
      undo,
      setPrevCaretPost,
      getCaretPosition,
      hasCaretPosChangedByUser
    ]
  );
  const handleOnClick = (0, import_react2.useCallback)(
    (e) => {
      e.stopImmediatePropagation();
      detectCaretChange();
    },
    [detectCaretChange]
  );
  (0, import_react2.useEffect)(() => {
    const editable = el;
    editable == null ? void 0 : editable.addEventListener("click", handleOnClick);
    editable == null ? void 0 : editable.addEventListener("keydown", handleKeyDown);
    return () => {
      editable == null ? void 0 : editable.removeEventListener("keydown", handleKeyDown);
      editable == null ? void 0 : editable.removeEventListener("click", handleOnClick);
    };
  }, [el, handleKeyDown, handleOnClick]);
  return undoState;
};
var useUndo_default = useUndo;

// src/contentEditable/useCaretPositioning.tsx
var formattingElsAndAnchorElement = [
  "EM",
  "B",
  "STRONG",
  "I",
  "U",
  "MARK",
  "SMALL",
  "DEL",
  "INS",
  "SUB",
  "TT",
  "BIG",
  "A"
];
var getFirstTextNode = (element) => {
  let textNode = element;
  while (textNode == null ? void 0 : textNode.firstChild) {
    textNode = textNode.firstChild;
  }
  return textNode;
};
var getAnyMainParentIncluded = (node, list) => {
  var _a;
  let parent = node;
  if (!(parent == null ? void 0 : parent.parentElement))
    return null;
  let isParentAnyOfList = list.includes(((_a = parent.parentElement) == null ? void 0 : _a.tagName) || "");
  while (isParentAnyOfList) {
    const pare = (parent == null ? void 0 : parent.parentElement) || null;
    if (list.includes(pare.tagName) && !(pare == null ? void 0 : pare.hasAttribute("contenteditable"))) {
      parent = pare;
    } else {
      isParentAnyOfList = false;
    }
  }
  if (list.includes((parent == null ? void 0 : parent.tagName) || "") === false) {
    return null;
  }
  return parent;
};
var getMainHTMLFormattingOrAnchorElement = (node) => {
  return getAnyMainParentIncluded(node, formattingElsAndAnchorElement);
};
var getNeighboringNode = (node, endOffset) => {
  var _a, _b, _c, _d;
  let prev = null;
  let next = null;
  let current = null;
  let parent = node.nodeType === 1 ? node.childNodes[endOffset] : node;
  let hasNoSibling = true;
  let i = 0;
  while (hasNoSibling) {
    if (next && prev) {
      hasNoSibling = false;
      break;
    }
    if (next === null && (parent == null ? void 0 : parent.nextSibling)) {
      const indexOfNext = Array.prototype.indexOf.call(
        (_a = parent == null ? void 0 : parent.parentElement) == null ? void 0 : _a.childNodes,
        parent.nextSibling
      );
      if (!current) {
        current = parent;
      }
      next = ((_b = parent.parentElement) == null ? void 0 : _b.childNodes[indexOfNext]) || null;
    }
    if (prev === null && (parent == null ? void 0 : parent.previousSibling)) {
      const indexOfPrev = Array.prototype.indexOf.call(
        (_c = parent == null ? void 0 : parent.parentElement) == null ? void 0 : _c.childNodes,
        parent.previousSibling
      );
      if (!current) {
        current = parent;
      }
      prev = ((_d = parent.parentElement) == null ? void 0 : _d.childNodes[indexOfPrev]) || null;
    }
    parent = parent == null ? void 0 : parent.parentElement;
    if (parent == null ? void 0 : parent.hasAttribute("contenteditable")) {
      break;
    }
    if (i > 1e3) {
      break;
    }
    i++;
  }
  return { prev, next, current };
};
var useCaretPositioning = () => {
  const refElement = (0, import_react4.useRef)(null);
  const [content, setContent] = (0, import_react4.useState)("");
  const {
    saveRange,
    restoreCaretPosition,
    getMatchedContainers,
    caretPosition,
    setCaretPosition
  } = useSaveRestoreRange_default(refElement.current);
  const isCaretAfterBR = (0, import_react4.useRef)(false);
  const undoState = useUndo_default(refElement.current);
  const triggerInput = () => {
    var _a;
    const ev = new Event("input", {
      bubbles: true,
      cancelable: true
    });
    (_a = refElement.current) == null ? void 0 : _a.dispatchEvent(ev);
  };
  const navigateThroughNestedElementsOnArrowKeys = (0, import_react4.useCallback)(
    (e) => {
      var _a, _b;
      let arrowDir = e.key === "ArrowRight" || e.key === "ArrowLeft" ? e.key : null;
      if (!arrowDir)
        return;
      if (refElement.current && getComputedStyle(refElement.current).direction === "rtl") {
        arrowDir = arrowDir === "right" ? "left" : "right";
      }
      const sel = document.getSelection();
      const range = getRange();
      const endContainer = range == null ? void 0 : range.endContainer;
      const endOffset = range == null ? void 0 : range.endOffset;
      if (!range || !endContainer || typeof endOffset === "undefined")
        return;
      const { prev, next, current } = getNeighboringNode(
        endContainer,
        endOffset
      );
      if (!prev && !next)
        return;
      const isAtEnd = ((_a = endContainer == null ? void 0 : endContainer.textContent) == null ? void 0 : _a.length) === (range == null ? void 0 : range.endOffset);
      const isAtStart = endOffset === 0 || endOffset === 1 || (endContainer == null ? void 0 : endContainer.nodeType) === 1;
      const isCurrentFormattingEls = !!getMainHTMLFormattingOrAnchorElement(endContainer);
      const isNextFormattingEls = !!getMainHTMLFormattingOrAnchorElement(
        next
      );
      const isPrevFormattingEls = !!getMainHTMLFormattingOrAnchorElement(
        prev
      );
      const isNavigatingThroughFormattingEls = (isCurrentFormattingEls || isNextFormattingEls || isPrevFormattingEls) && (isAtStart || isAtEnd);
      if (next && isAtEnd && arrowDir === "right" && (next == null ? void 0 : next.tagName) === "BR" && isCaretAfterBR.current === false) {
        e.preventDefault();
        range.setStartAfter(next);
        range.setEndAfter(next);
        sel == null ? void 0 : sel.removeAllRanges();
        sel == null ? void 0 : sel.addRange(range);
        isCaretAfterBR.current = true;
      } else if (arrowDir === "right" && (current == null ? void 0 : current.previousSibling) && isCaretAfterBR.current === true) {
        e.preventDefault();
        range.setStart(current, 0);
        range.setEnd(current, 0);
        sel == null ? void 0 : sel.removeAllRanges();
        sel == null ? void 0 : sel.addRange(range);
      }
      if (!isNavigatingThroughFormattingEls)
        return;
      if (arrowDir === "right" && !next || arrowDir === "left" && !prev)
        return;
      if (current && next && arrowDir === "right" && isAtEnd) {
        e.preventDefault();
        if (current.nodeType !== 1 || next.nodeType !== 1) {
          range.setStart(getFirstTextNode(next), 0);
          range.setEnd(getFirstTextNode(next), 0);
        } else {
          range.setStartAfter(current);
          range.setEndAfter(current);
        }
      } else if (current && arrowDir === "right" && (range == null ? void 0 : range.endContainer.nodeType) === 1) {
        e.preventDefault();
        range.setStart(getFirstTextNode(current), 0);
        range.setEnd(getFirstTextNode(current), 0);
      }
      if (current && prev && arrowDir === "left" && isAtStart) {
        e.preventDefault();
        const prevLength = prev.nodeType === 1 ? (_b = prev.childNodes) == null ? void 0 : _b.length : prev.length;
        const prevContainer = prev.childNodes[prevLength - 1];
        if (range.endContainer.nodeType !== 1 && endOffset === 1) {
          range.setStart(endContainer, 0);
          range.setEnd(endContainer, 0);
        } else {
          if (current.nodeType !== 1 && prev.nodeType === 1 || (current == null ? void 0 : current.nodeType) === 1 && prev.nodeType === 1 && range.endOffset !== 0) {
            range.setStart(
              prevContainer,
              prevContainer.length
            );
            range.setEnd(
              prevContainer,
              prevContainer.length
            );
          } else if ((current == null ? void 0 : current.nodeType) === 1 && (range == null ? void 0 : range.endContainer.nodeType) !== 1 && prev.nodeType === 1) {
            range.setStartBefore(current);
            range.setEndBefore(current);
          } else {
            if (prev.tagName === "BR" && isCaretAfterBR.current === false) {
              range.setStartAfter(prev);
              range.setEndAfter(prev);
              isCaretAfterBR.current = true;
            } else {
              range.setStart(prev, prev.length);
              range.setEnd(prev, prev.length);
            }
          }
        }
      }
      sel == null ? void 0 : sel.removeAllRanges();
      sel == null ? void 0 : sel.addRange(range);
      setTimeout(() => isCaretAfterBR.current = false, 0);
    },
    []
  );
  const jumpOutsideFormattingElementWhenAtEndContainer = (0, import_react4.useCallback)(() => {
    var _a, _b;
    const range = getRange();
    const selection = document.getSelection();
    const endContainer = range == null ? void 0 : range.endContainer;
    if ((endContainer == null ? void 0 : endContainer.textContent) !== (range == null ? void 0 : range.startContainer.textContent) || (range == null ? void 0 : range.startOffset) !== (range == null ? void 0 : range.endOffset))
      return;
    if (!refElement.current || !endContainer || !range)
      return;
    const formattingElement = endContainer.parentElement;
    if (formattingElement && ((_a = getMainHTMLFormattingOrAnchorElement(endContainer)) == null ? void 0 : _a.nodeType) === 1 && ((_b = endContainer.textContent) == null ? void 0 : _b.length) === range.endOffset) {
      if (endContainer.nextSibling && endContainer.previousSibling) {
        return;
      }
      range.setStartAfter(formattingElement);
      range.setEndAfter(formattingElement);
      range.collapse();
      selection == null ? void 0 : selection.removeAllRanges();
      selection == null ? void 0 : selection.addRange(range);
    }
  }, []);
  const moveCaretOutsideFormattingElementWhenAtOffsetZeroAndAfterBR = (0, import_react4.useCallback)(() => {
    var _a;
    const range = getRange();
    const selection = document.getSelection();
    const endContainer = range == null ? void 0 : range.endContainer;
    if ((endContainer == null ? void 0 : endContainer.textContent) !== (range == null ? void 0 : range.startContainer.textContent) || (range == null ? void 0 : range.startOffset) !== (range == null ? void 0 : range.endOffset))
      return;
    if (!refElement.current || !endContainer || !range)
      return;
    const mainElementFormattingEl = getMainHTMLFormattingOrAnchorElement(endContainer);
    if (((_a = mainElementFormattingEl == null ? void 0 : mainElementFormattingEl.previousSibling) == null ? void 0 : _a.tagName) === "BR" && (mainElementFormattingEl == null ? void 0 : mainElementFormattingEl.nodeType) === 1 && range.startOffset === 0) {
      range.setStartBefore(mainElementFormattingEl);
      range.setEndBefore(mainElementFormattingEl);
      selection == null ? void 0 : selection.removeAllRanges();
      selection == null ? void 0 : selection.addRange(range);
    }
  }, []);
  const inputCharManuallyWhenCaretAtStartOrEndTextOrBtwnFormattingElements = (0, import_react4.useCallback)(
    (e) => {
      var _a, _b, _c, _d, _e;
      const compositionEvent = e;
      const keyDownEvent = e;
      const sel = getSelection();
      const range = getRange();
      if (((_a = range == null ? void 0 : range.endContainer) == null ? void 0 : _a.textContent) !== (range == null ? void 0 : range.startContainer.textContent) || (range == null ? void 0 : range.startOffset) !== (range == null ? void 0 : range.endOffset))
        return;
      let newValue = (keyDownEvent == null ? void 0 : keyDownEvent.data) || (compositionEvent == null ? void 0 : compositionEvent.data);
      if (range && (((_b = range == null ? void 0 : range.endContainer.textContent) == null ? void 0 : _b.length) === range.endOffset || (range == null ? void 0 : range.endContainer.nodeType) === 1 || range.endOffset === 0)) {
        if (!newValue && !/\s/g.test(newValue))
          return;
        newValue = /\s/g.test(newValue) ? "white_space_&nbsp;" : newValue;
        e.preventDefault();
        if (range.endContainer.nodeType !== 1) {
          if (range.endOffset === 0) {
            const content2 = range.endContainer.textContent;
            const newContent = newValue + content2;
            range.endContainer.nodeValue = newContent;
            range.setStart(range.endContainer, 1);
            range.setEnd(range.endContainer, 1);
          } else {
            const content2 = range.endContainer.textContent;
            const newContent = content2 + newValue;
            range.endContainer.nodeValue = newContent;
            const endOffset = newValue === "white_space_&nbsp;" ? ((content2 == null ? void 0 : content2.length) || 0) + 1 : newContent.length;
            range.setStart(range.endContainer, endOffset);
            range.setEnd(range.endContainer, endOffset);
          }
        } else {
          const newTextNode = document.createTextNode(newValue);
          const isAfterBR = ((_c = range == null ? void 0 : range.endContainer.childNodes[(range == null ? void 0 : range.endOffset) - 1]) == null ? void 0 : _c.tagName) === "BR";
          const prev = range == null ? void 0 : range.endContainer.childNodes[(range == null ? void 0 : range.endOffset) - 1];
          const next = range == null ? void 0 : range.endContainer.childNodes[(range == null ? void 0 : range.endOffset) + 1];
          let current = range == null ? void 0 : range.endContainer.childNodes[range == null ? void 0 : range.endOffset];
          const isBetweenFormattingElements = formattingElsAndAnchorElement.includes(
            prev == null ? void 0 : prev.tagName
          ) && formattingElsAndAnchorElement.includes(
            next == null ? void 0 : next.tagName
          );
          if (!current && (range == null ? void 0 : range.endContainer).hasAttribute(
            "contenteditable"
          )) {
            range.insertNode(newTextNode);
            range.setStart(range.endContainer, 1);
            range.setEnd(range.endContainer, 1);
          } else if (isAfterBR && next || isBetweenFormattingElements) {
            range.insertNode(newTextNode);
            range.setStart(newTextNode, 1);
            range.setEnd(newTextNode, 1);
          } else if (!next && (current == null ? void 0 : current.tagName) === "BR") {
            const parent = current.parentElement;
            parent == null ? void 0 : parent.removeChild(current);
            parent == null ? void 0 : parent.append(newTextNode);
            range.setStart(newTextNode, 1);
            range.setEnd(newTextNode, 1);
          } else {
            if (range.endContainer.nodeType === 1) {
              range.insertNode(newTextNode);
              range.setStart(newTextNode, 1);
              range.setEnd(newTextNode, 1);
            } else {
              range.endContainer.nodeValue = range.endContainer.nodeValue + newValue;
              range.setStart(
                range.endContainer,
                range.endContainer.length
              );
              range.setEnd(
                range.endContainer,
                range.endContainer.length
              );
            }
          }
        }
        sel == null ? void 0 : sel.removeAllRanges();
        sel == null ? void 0 : sel.addRange(range);
        saveRange();
        if ((_d = refElement.current) == null ? void 0 : _d.innerHTML) {
          refElement.current.innerHTML = (_e = refElement.current) == null ? void 0 : _e.innerHTML.replaceAll(
            "white_space_&amp;nbsp;",
            "&nbsp;"
          );
        }
        setTimeout(triggerInput, 0);
      }
    },
    [saveRange]
  );
  const correctInputDataContainerIME = (0, import_react4.useCallback)(
    (e) => {
      var _a;
      const sel = document.getSelection();
      const range = getRange();
      const currentEndContainer = range == null ? void 0 : range.endContainer;
      const currentEndOffset = range == null ? void 0 : range.endOffset;
      const originalEndContainer = ((_a = getMatchedContainers()) == null ? void 0 : _a.end) || null;
      const originalEndOffset = caretPosition == null ? void 0 : caretPosition.endOffset;
      if (originalEndOffset !== (caretPosition == null ? void 0 : caretPosition.startOffset))
        return;
      if (range && originalEndContainer && currentEndContainer && currentEndOffset && typeof originalEndOffset === "number" && !(currentEndContainer == null ? void 0 : currentEndContainer.isEqualNode(originalEndContainer))) {
        const dataLength = e.data.length;
        const newInputDataStartOffset = Math.abs(
          dataLength - currentEndOffset
        );
        const newInputDataEndOffset = currentEndOffset;
        range.selectNodeContents(currentEndContainer);
        range.setStart(currentEndContainer, newInputDataStartOffset);
        range.setEnd(currentEndContainer, newInputDataEndOffset);
        const newInputData = range.extractContents().textContent;
        const newInputDataNode = document.createTextNode(
          newInputData || ""
        );
        range.setStart(originalEndContainer, originalEndOffset);
        range.setEnd(originalEndContainer, originalEndOffset);
        if (originalEndContainer.nodeType === 1) {
          range.insertNode(newInputDataNode);
          range.setStart(newInputDataNode, dataLength);
          range.setEnd(newInputDataNode, dataLength);
        } else {
          if (originalEndOffset === originalEndContainer.length) {
            originalEndContainer.nodeValue = (originalEndContainer.nodeValue || "") + newInputData;
            const containerLength = originalEndContainer.length;
            range.setStart(originalEndContainer, containerLength);
            range.setEnd(originalEndContainer, containerLength);
          } else {
            originalEndContainer.nodeValue = newInputData + (originalEndContainer.nodeValue || "");
            range.setStart(originalEndContainer, dataLength);
            range.setEnd(originalEndContainer, dataLength);
          }
        }
        sel == null ? void 0 : sel.removeAllRanges();
        sel == null ? void 0 : sel.addRange(range);
      }
    },
    [caretPosition, getMatchedContainers]
  );
  const handleInputIME = (e) => {
    const content2 = e.target.innerHTML;
    correctInputDataContainerIME(e);
    saveRange();
    setContent(content2);
  };
  const handleInput = (e) => {
    const content2 = e.target.innerHTML;
    saveRange();
    setContent(content2);
  };
  (0, import_react4.useLayoutEffect)(() => {
    restoreCaretPosition();
  }, [restoreCaretPosition]);
  const handleKeyDown = (0, import_react4.useCallback)(
    (e) => {
      navigateThroughNestedElementsOnArrowKeys(e);
      if (e.shiftKey && e.key === "Enter") {
        setTimeout(
          moveCaretOutsideFormattingElementWhenAtOffsetZeroAndAfterBR,
          0
        );
      }
    },
    [
      navigateThroughNestedElementsOnArrowKeys,
      moveCaretOutsideFormattingElementWhenAtOffsetZeroAndAfterBR
    ]
  );
  const handleCompositionStart = (0, import_react4.useCallback)(
    (_e) => {
      saveRange();
    },
    [saveRange]
  );
  (0, import_react4.useLayoutEffect)(() => {
    const el = refElement.current;
    const handleInput2 = (e) => {
      if (!e.isComposing) {
        inputCharManuallyWhenCaretAtStartOrEndTextOrBtwnFormattingElements(
          e
        );
      }
    };
    const handleOnClick = (_e) => {
      moveCaretOutsideFormattingElementWhenAtOffsetZeroAndAfterBR();
      jumpOutsideFormattingElementWhenAtEndContainer();
    };
    el == null ? void 0 : el.addEventListener("click", handleOnClick);
    el == null ? void 0 : el.addEventListener("beforeinput", handleInput2);
    return () => {
      el == null ? void 0 : el.removeEventListener("click", handleOnClick);
      el == null ? void 0 : el.removeEventListener("beforeinput", handleInput2);
    };
  }, [
    jumpOutsideFormattingElementWhenAtEndContainer,
    moveCaretOutsideFormattingElementWhenAtOffsetZeroAndAfterBR,
    inputCharManuallyWhenCaretAtStartOrEndTextOrBtwnFormattingElements
  ]);
  (0, import_react4.useLayoutEffect)(() => {
    if (typeof (undoState == null ? void 0 : undoState.html) !== "undefined" && (undoState == null ? void 0 : undoState.caretPosition)) {
      setContent(undoState == null ? void 0 : undoState.html);
      setCaretPosition(undoState == null ? void 0 : undoState.caretPosition);
    }
  }, [undoState, setCaretPosition]);
  return {
    refElement,
    content,
    setContent,
    handleKeyDown,
    handleInput,
    handleInputIME,
    handleCompositionStart
  };
};
var useCaretPositioning_default = useCaretPositioning;

// src/contentEditable/index.tsx
var import_react6 = __toESM(require("fast-deep-equal/react"));
var Editable = (0, import_react5.forwardRef)(
  ({
    tagName = "div",
    onChange,
    html,
    onKeyDown,
    onInput,
    onCompositionStart,
    onCompositionEnd,
    ...rest
  }, ref) => {
    const {
      refElement,
      content,
      setContent,
      handleInput,
      handleKeyDown,
      handleInputIME,
      handleCompositionStart,
      ...props
    } = useCaretPositioning_default();
    const isComposing = (0, import_react5.useRef)(false);
    const handleOnChange = (e) => {
      if (isComposing.current) {
        return;
      }
      handleInput(e);
      const htmlContent = e.target.innerHTML;
      const evt = Object.assign({}, e, {
        target: {
          value: htmlContent
        }
      });
      onChange == null ? void 0 : onChange(evt);
      onInput == null ? void 0 : onInput(e);
    };
    const handleKeydown = (e) => {
      const evt = Object.assign({}, e, {
        isComposing: isComposing.current,
        preventDefault: e.preventDefault
      });
      handleKeyDown(evt);
      onKeyDown == null ? void 0 : onKeyDown(evt);
    };
    const _handleCompositionStart = (e) => {
      isComposing.current = true;
      handleCompositionStart(e);
      onCompositionStart == null ? void 0 : onCompositionStart(e);
    };
    const handleCompositionEnd = (e) => {
      handleInputIME(e);
      isComposing.current = false;
      onCompositionEnd == null ? void 0 : onCompositionEnd(e);
    };
    (0, import_react5.useLayoutEffect)(() => {
      if (typeof html !== "string")
        return;
      setContent(html);
    }, [html, setContent]);
    return import_react5.default.createElement(tagName, {
      onCompositionStart: _handleCompositionStart,
      onCompositionEnd: handleCompositionEnd,
      onKeyDown: handleKeydown,
      onInput: handleOnChange,
      dangerouslySetInnerHTML: { __html: content },
      contentEditable: true,
      ref: (0, import_react_merge_refs.mergeRefs)([refElement, ref]),
      dir: "auto",
      ...props,
      ...rest
    });
  }
);
var isPropsEqual = (prevProp, nextProp) => {
  return (0, import_react6.default)(prevProp, nextProp);
};
var ContentEditable = (0, import_react5.memo)(Editable, isPropsEqual);
var contentEditable_default = ContentEditable;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map